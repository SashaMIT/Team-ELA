<!DOCTYPE html>
<html>
<head>
  <style>
    .container {
      width: 100%;
      height: 400px;
      display: flex;
      justify-content: center;
      align-items: center;
      background: white;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="sphereCanvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('sphereCanvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 800;
    canvas.height = 400;
    
    class NetworkSphere {
      constructor(centerX, color, size, numPoints) {
        this.centerX = centerX;
        this.color = color;
        this.baseRadius = size;
        this.points = [];
        this.rotation = 0;
        this.connectionThreshold = size * 0.45;
        
        for (let i = 0; i < numPoints; i++) {
          this.points.push(this.createPoint());
        }
        
        this.establishConnections();
      }
      
      createPoint() {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const radiusVariation = this.baseRadius * (0.6 + Math.random() * 0.6);
        
        const x = radiusVariation * Math.sin(phi) * Math.cos(theta);
        const y = radiusVariation * Math.sin(phi) * Math.sin(theta);
        const z = radiusVariation * Math.cos(phi);
        
        return {
          x, y, z,
          baseX: x, baseY: y, baseZ: z,
          vx: (Math.random() - 0.5) * 1,
          vy: (Math.random() - 0.5) * 1,
          vz: (Math.random() - 0.5) * 1,
          opacity: 0.3 + Math.random() * 0.7,
          opacitySpeed: 0.001 + Math.random() * 0.003,
          opacityDirection: Math.random() < 0.5 ? 1 : -1,
          size: 0.5 + Math.random() * 0.6, // Increased point size
          phase: Math.random() * Math.PI * 4,
          breatheSpeed: 0.002 + Math.random() * 0.004,
          breatheAmount: 0.02 + Math.random() * 0.08,
          moveSpeed: 0.004 + Math.random() * 0.008,
          connectionStrength: 0.4 + Math.random() * 0.6,
          activeState: Math.random() > 0.3,
          maxConnections: Math.floor(5 + Math.random() * 15),
          preferredConnections: []
        };
      }
      
      establishConnections() {
        this.points.forEach((point1, i) => {
          const connections = [];
          this.points.forEach((point2, j) => {
            if (i !== j) {
              const dx = point1.baseX - point2.baseX;
              const dy = point1.baseY - point2.baseY;
              const dz = point1.baseZ - point2.baseZ;
              const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
              if (distance < this.connectionThreshold) {
                connections.push({
                  index: j,
                  strength: 1 - (distance / this.connectionThreshold)
                });
              }
            }
          });
          connections.sort((a, b) => b.strength - a.strength);
          point1.preferredConnections = connections.slice(0, point1.maxConnections);
        });
      }
      
      update(time, globalBreathing) {
        const globalBreatheFactor = Math.sin(globalBreathing) * 0.08;
        
        this.points.forEach(point => {
          if (Math.random() < 0.0003) {
            point.activeState = !point.activeState;
          }
          
          if (point.activeState) {
            const individualBreathing = Math.sin(time * point.breatheSpeed + point.phase);
            const breatheFactor = (globalBreatheFactor + individualBreathing * point.breatheAmount);
            
            point.x = point.baseX * (1 + breatheFactor);
            point.y = point.baseY * (1 + breatheFactor);
            point.z = point.baseZ * (1 + breatheFactor);
            
            point.x += point.vx * Math.sin(time * point.moveSpeed) * 0.15;
            point.y += point.vy * Math.cos(time * point.moveSpeed * 0.8) * 0.15;
            point.z += point.vz * Math.sin(time * point.moveSpeed * 1.2) * 0.15;
            
            point.opacity = Math.min(1, point.opacity + point.opacitySpeed * point.opacityDirection);
            
            if (point.opacity > 0.9) point.opacityDirection = -1;
            if (point.opacity < 0.3) point.opacityDirection = 1;
          } else {
            point.opacity = Math.max(0.2, point.opacity - 0.003);
          }
          
          const dist = Math.sqrt(point.x * point.x + point.y * point.y + point.z * point.z);
          if (dist > this.baseRadius) {
            const scale = this.baseRadius / dist;
            point.x *= scale;
            point.y *= scale;
            point.z *= scale;
            point.vx *= -0.5;
            point.vy *= -0.5;
            point.vz *= -0.5;
          }
        });
        
        this.rotation += 0.0006;
      }
      
      draw(ctx) {
        const rotatedPoints = this.points.map(point => ({
          ...point,
          screenX: this.centerX + (point.x * Math.cos(this.rotation) - point.z * Math.sin(this.rotation)),
          screenY: point.y,
          screenZ: point.x * Math.sin(this.rotation) + point.z * Math.cos(this.rotation)
        }));
        
        ctx.lineWidth = 0.5;
        rotatedPoints.forEach((point1, i) => {
          point1.preferredConnections.forEach(conn => {
            const point2 = rotatedPoints[conn.index];
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < this.connectionThreshold) {
              const distanceFactor = 1 - (distance / this.connectionThreshold);
              const combinedStrength = point1.connectionStrength * point2.connectionStrength * conn.strength;
              const opacity = Math.min(point1.opacity, point2.opacity) * 0.15 * distanceFactor * combinedStrength;
              
              if (opacity > 0.01) {
                ctx.strokeStyle = `${this.color.replace('1)', opacity + ')')}`;
                ctx.beginPath();
                ctx.moveTo(point1.screenX, point1.screenY);
                ctx.lineTo(point2.screenX, point2.screenY);
                ctx.stroke();
                
                ctx.strokeStyle = `${this.color.replace('1)', opacity * 0.3 + ')')}`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(point1.screenX, point1.screenY);
                ctx.lineTo(point2.screenX, point2.screenY);
                ctx.stroke();
              }
            }
          });
        });
        
        rotatedPoints.forEach(point => {
          if (point.opacity > 0.05) {
            const size = point.size;
            const gradient = ctx.createRadialGradient(
              point.screenX, point.screenY, 0,
              point.screenX, point.screenY, size * 2
            );
            gradient.addColorStop(0, `${this.color.replace('1)', point.opacity * 0.4 + ')')}`);
            gradient.addColorStop(1, `${this.color.replace('1)', '0)')}`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(point.screenX, point.screenY, size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = `${this.color.replace('1)', point.opacity + ')')}`;
            ctx.beginPath();
            ctx.arc(point.screenX, point.screenY, size, 0, Math.PI * 2);
            ctx.fill();
          }
        });
      }
    }
    
    const orangeSphere = new NetworkSphere(280, 'rgba(204, 85, 0, 1)', 150, 2400);
    const blackSphere = new NetworkSphere(520, 'rgba(0, 0, 0, 1)', 120, 2000);
    
    let time = 0;
    let globalBreathing = 0;
    
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(0, canvas.height / 2);
      
      globalBreathing += 0.004;
      
      orangeSphere.update(time, globalBreathing);
      blackSphere.update(time, globalBreathing);
      
      orangeSphere.draw(ctx);
      blackSphere.draw(ctx);
      
      ctx.restore();
      
      time += 0.5;
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>